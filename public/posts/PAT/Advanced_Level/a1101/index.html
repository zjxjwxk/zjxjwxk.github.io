<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PAT甲级 1101 Quick Sort (25分) | Xinkang&#39;s Blog</title>
<meta name="keywords" content="PAT">
<meta name="description" content="There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?
For example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have:">
<meta name="author" content="">
<link rel="canonical" href="https://zjxjwxk.github.io/posts/pat/advanced_level/a1101/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zjxjwxk.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zjxjwxk.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zjxjwxk.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zjxjwxk.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zjxjwxk.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://zjxjwxk.github.io/posts/pat/advanced_level/a1101/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://zjxjwxk.github.io/posts/pat/advanced_level/a1101/">
  <meta property="og:site_name" content="Xinkang&#39;s Blog">
  <meta property="og:title" content="PAT甲级 1101 Quick Sort (25分)">
  <meta property="og:description" content="There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?
For example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have:">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-03-29T17:27:00+00:00">
    <meta property="article:modified_time" content="2020-03-29T17:27:00+00:00">
    <meta property="article:tag" content="PAT">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PAT甲级 1101 Quick Sort (25分)">
<meta name="twitter:description" content="There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?
For example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have:">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zjxjwxk.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "PAT甲级 1101 Quick Sort (25分)",
      "item": "https://zjxjwxk.github.io/posts/pat/advanced_level/a1101/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PAT甲级 1101 Quick Sort (25分)",
  "name": "PAT甲级 1101 Quick Sort (25分)",
  "description": "There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?\nFor example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have:\n",
  "keywords": [
    "PAT"
  ],
  "articleBody": "There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?\nFor example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have:\n1 could be the pivot since there is no element to its left and all the elements to its right are larger than it; 3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well; 2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well; and for the similar reason, 4 and 5 could also be the pivot. Hence in total there are 3 pivot candidates.\nInput Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (≤10^5). Then the next line contains N distinct positive integers no larger than 10^9. The numbers in a line are separated by spaces.\nOutput Specification: For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.\nSample Input: 5 1 3 2 4 5 Sample Output: 3 1 4 5 思路 定义两个数组 leftMax[maxn] 和 leftMax[maxn]，leftMax[maxn] 用于记录序列中每一位左边的最大值，leftMax[maxn] 用于记录序列中每一位右边的最小值。如果 nums[i] 大于左边的最大值 leftMax[i] 且小于右边的最小值 rightMin[i]，那么 nums[i] 一定可以作为主元。 其中，leftMax[0] 应设为0，这样就假设了 nums[0] 左边没有比它大的元素；rightMin[n - 1] 应设为最大值 1 « 31 - 1，这样就假设了 nums[n - 1] 右边没有比它小的元素。这样在给这两个数组赋值的过程中，相当于把初始最大值设为了 nums[0] 即 0，把初始最小值设为了 nums[n - 1] 即 1 « 31 - 1。同时在判断主元时方便了边界元素的判断， 注意点 直接暴力判断的做法会超时 当主元个数为0时，第二行虽然没有输出主元，但必须输出一个换行（否则会有一个点格式错误…） #include #include using namespace std; const int maxn = 100000; int main() { int n, nums[maxn], leftMax[maxn], rightMin[maxn]; scanf(\"%d\", \u0026n); leftMax[0] = 0; rightMin[n - 1] = 1 \u003c\u003c 31 - 1; for (int i = 0; i \u003c n; i++) { scanf(\"%d\", \u0026nums[i]); if (i != n - 1) { if (nums[i] \u003e leftMax[i]) { leftMax[i + 1] = nums[i]; } else { leftMax[i + 1] = leftMax[i]; } } } for (int i = n - 1; i \u003e= 1; i--) { if (nums[i] \u003c rightMin[i]) { rightMin[i - 1] = nums[i]; } else { rightMin[i - 1] = rightMin[i]; } } vector\u003cint\u003e ans; for (int i = 0; i \u003c n; i++) { if (nums[i] \u003e leftMax[i] \u0026\u0026 nums[i] \u003c rightMin[i]) { ans.push_back(nums[i]); } } printf(\"%d\\n\", ans.size()); for (int i = 0; i \u003c ans.size(); i++) { printf(\"%d\", ans[i]); if (i != ans.size() - 1) { printf(\" \"); } } printf(\"\\n\"); return 0; } ",
  "wordCount" : "493",
  "inLanguage": "en",
  "datePublished": "2020-03-29T17:27:00Z",
  "dateModified": "2020-03-29T17:27:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zjxjwxk.github.io/posts/pat/advanced_level/a1101/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Xinkang's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zjxjwxk.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zjxjwxk.github.io/" accesskey="h" title="Xinkang&#39;s Blog (Alt + H)">Xinkang&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zjxjwxk.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://zjxjwxk.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://zjxjwxk.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://zjxjwxk.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <div id="content-container">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      PAT甲级 1101 Quick Sort (25分)
    </h1>
    <div class="post-meta"><span title='2020-03-29 17:27:00 +0000 UTC'>March 29, 2020</span>

</div>
  </header> 
  <div class="post-content"><p>There is a classical process named <strong>partition</strong> in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given <em>N</em> distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?</p>
<p>For example, given <em>N</em>=5 and the numbers 1, 3, 2, 4, and 5. We have:</p>
<ul>
<li>1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;</li>
<li>3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;</li>
<li>2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;</li>
<li>and for the similar reason, 4 and 5 could also be the pivot.</li>
</ul>
<p>Hence in total there are 3 pivot candidates.</p>
<h1 id="input-specification">Input Specification:<a hidden class="anchor" aria-hidden="true" href="#input-specification">#</a></h1>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤10^5). Then the next line contains <em>N</em> distinct positive integers no larger than 10^9. The numbers in a line are separated by spaces.</p>
<h1 id="output-specification">Output Specification:<a hidden class="anchor" aria-hidden="true" href="#output-specification">#</a></h1>
<p>For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p>
<h1 id="sample-input">Sample Input:<a hidden class="anchor" aria-hidden="true" href="#sample-input">#</a></h1>
<pre tabindex="0"><code class="language-in" data-lang="in">5
1 3 2 4 5
</code></pre><h1 id="sample-output">Sample Output:<a hidden class="anchor" aria-hidden="true" href="#sample-output">#</a></h1>
<pre tabindex="0"><code class="language-out" data-lang="out">3
1 4 5
</code></pre><h1 id="思路">思路<a hidden class="anchor" aria-hidden="true" href="#思路">#</a></h1>
<ul>
<li>定义两个数组 leftMax[maxn] 和 leftMax[maxn]，leftMax[maxn] 用于记录序列中每一位左边的最大值，leftMax[maxn] 用于记录序列中每一位右边的最小值。如果 nums[i] 大于左边的最大值 leftMax[i] 且小于右边的最小值 rightMin[i]，那么 nums[i] 一定可以作为主元。</li>
<li>其中，leftMax[0] 应设为0，这样就假设了 nums[0] 左边没有比它大的元素；rightMin[n - 1] 应设为最大值 1 &laquo; 31 - 1，这样就假设了 nums[n - 1] 右边没有比它小的元素。这样在给这两个数组赋值的过程中，相当于把初始最大值设为了 nums[0] 即 0，把初始最小值设为了 nums[n - 1] 即 1 &laquo; 31 - 1。同时在判断主元时方便了边界元素的判断，</li>
</ul>
<h1 id="注意点">注意点<a hidden class="anchor" aria-hidden="true" href="#注意点">#</a></h1>
<ul>
<li>直接暴力判断的做法会超时</li>
<li>当主元个数为0时，第二行虽然没有输出主元，但必须输出一个换行（否则会有一个点格式错误&hellip;）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn <span style="color:#f92672">=</span> <span style="color:#ae81ff">100000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n, nums[maxn], leftMax[maxn], rightMin[maxn];
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    leftMax[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    rightMin[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">31</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>nums[i]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">&gt;</span> leftMax[i]) {
</span></span><span style="display:flex;"><span>                leftMax[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> nums[i];
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                leftMax[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> leftMax[i];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">&lt;</span> rightMin[i]) {
</span></span><span style="display:flex;"><span>            rightMin[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> nums[i];
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            rightMin[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> rightMin[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ans;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nums[i] <span style="color:#f92672">&gt;</span> leftMax[i] <span style="color:#f92672">&amp;&amp;</span> nums[i] <span style="color:#f92672">&lt;</span> rightMin[i]) {
</span></span><span style="display:flex;"><span>            ans.push_back(nums[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans.size());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> ans.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%d&#34;</span>, ans[i]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> ans.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://zjxjwxk.github.io/tags/pat/">PAT</a></li>
    </ul>
  </footer>
</article>

<script>
  window.onload = function() {
      var contentContainer = document.getElementById("content-container");
      if ("" !== "") {
          var password = prompt("Enter password:");
          if (password === "") {
              contentContainer.style.display = "block";
          } else {
              alert("Incorrect password");
          }
      } else {
          contentContainer.style.display = "block";
      }
  };
</script>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://zjxjwxk.github.io/">Xinkang&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
